from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path


@dataclass
class ProjectConfig:
    name: str
    sensors: list[str]
    anomalies: list[str]
    environments: list[str]


def _yaml_lines(data: object, indent: int = 0) -> list[str]:
    prefix = "  " * indent
    if isinstance(data, dict):
        lines: list[str] = []
        for key, value in data.items():
            if isinstance(value, (dict, list)):
                lines.append(f"{prefix}{key}:")
                lines.extend(_yaml_lines(value, indent + 1))
            else:
                lines.append(f"{prefix}{key}: {value}")
        return lines
    if isinstance(data, list):
        lines = []
        for item in data:
            if isinstance(item, (dict, list)):
                lines.append(f"{prefix}-")
                lines.extend(_yaml_lines(item, indent + 1))
            else:
                lines.append(f"{prefix}- {item}")
        return lines
    return [f"{prefix}{data}"]


def _write_yaml(path: Path, data: dict[str, object]) -> None:
    lines = _yaml_lines(data)
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def create_project(config: ProjectConfig, output_dir: Path) -> Path:
    project_dir = output_dir / config.name
    project_dir.mkdir(parents=True, exist_ok=True)

    config_dir = project_dir / "config"
    sensors_dir = project_dir / "sensors"
    simulated_dir = sensors_dir / "simulated"
    models_dir = project_dir / "models"
    pipelines_dir = project_dir / "pipelines"
    scripts_dir = project_dir / "scripts"
    data_dir = project_dir / "data"
    env_dir = project_dir / "environments"
    tests_dir = project_dir / "tests"

    for directory in [
        config_dir,
        simulated_dir,
        models_dir,
        pipelines_dir,
        scripts_dir,
        data_dir,
        env_dir,
        tests_dir,
    ]:
        directory.mkdir(parents=True, exist_ok=True)

    _write_yaml(
        config_dir / "wristband_config.yaml",
        {
            "project": {
                "name": config.name,
                "created_at": datetime.utcnow().isoformat(timespec="seconds") + "Z",
            },
            "sensors": config.sensors,
            "anomalies": config.anomalies,
            "environments": config.environments,
        },
    )

    (project_dir / "README.md").write_text(
        "# Wristband Sensor Fusion Project\n\n"
        "This project was generated by the Altrus CLI.\n"
        "Update `config/wristband_config.yaml` to adjust sensors, anomalies, or environments.\n\n"
        "## Quick start\n\n"
        "Run the live simulator loop in a new terminal:\n\n"
        "```bash\n"
        "python -m scripts.launch_live\n"
        "```\n\n"
        "Run the live loop in the current terminal:\n\n"
        "```bash\n"
        "python -m scripts.run_live\n"
        "```\n\n"
        "Run a short simulation test:\n\n"
        "```bash\n"
        "python -m tests.run_simulation\n"
        "```\n",
        encoding="utf-8",
    )

    (models_dir / "user_model.py").write_text(
        "\"\"\"Replace this stub with your trained model.\"\"\"\n\n"
        "class UserModel:\n"
        "    \"\"\"Simple threshold-based model for simulated sensor data.\"\"\"\n\n"
        "    def __init__(self, threshold: float = 2.5) -> None:\n"
        "        self.threshold = threshold\n\n"
        "    def predict(self, features: list[float]) -> dict:\n"
        "        \"\"\"Return a basic anomaly prediction using a threshold.\"\"\"\n"
        "        if not features:\n"
        "            return {\"anomaly\": False, \"score\": 0.0}\n"
        "        max_abs = max(abs(value) for value in features)\n"
        "        score = min(max_abs / self.threshold, 1.0)\n"
        "        return {\"anomaly\": max_abs >= self.threshold, \"score\": round(score, 3)}\n\n"
        "\n"
        "def load_model() -> UserModel:\n"
        "    return UserModel()\n",
        encoding="utf-8",
    )

    (pipelines_dir / "inference.py").write_text(
        "from __future__ import annotations\n\n"
        "from models.user_model import load_model\n\n"
        "\n"
        "def run_inference(features: list[float]) -> dict:\n"
        "    model = load_model()\n"
        "    return model.predict(features)\n",
        encoding="utf-8",
    )

    (scripts_dir / "run_inference.py").write_text(
        "from pipelines.inference import run_inference\n\n"
        "\n"
        "def main() -> None:\n"
        "    sample_features = [0.0, 0.0, 0.0]\n"
        "    result = run_inference(sample_features)\n"
        "    print(f\"Inference result: {result}\")\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (scripts_dir / "run_live.py").write_text(
        "from __future__ import annotations\n\n"
        "import time\n\n"
        "from pipelines.inference import run_inference\n"
        "from sensors.simulated.simulator import generate_sample\n\n"
        "\n"
        "def _extract_features(sample: dict) -> list[float]:\n"
        "    return [value for value in sample.values() if isinstance(value, (int, float))]\n\n"
        "\n"
        "def main() -> None:\n"
        "    print(\"Waiting for simulated sensors... (press Ctrl+C to stop)\")\n"
        "    while True:\n"
        "        sample = generate_sample()\n"
        "        features = _extract_features(sample)\n"
        "        prediction = run_inference(features)\n"
        "        status = \"ANOMALY\" if prediction[\"anomaly\"] else \"normal\"\n"
        "        print(f\"sample={sample} -> {status} (score={prediction['score']})\")\n"
        "        time.sleep(1.0)\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (scripts_dir / "launch_live.py").write_text(
        "from __future__ import annotations\n\n"
        "import os\n"
        "import platform\n"
        "import subprocess\n"
        "import sys\n\n"
        "\n"
        "def main() -> None:\n"
        "    command = [sys.executable, \"-m\", \"scripts.run_live\"]\n"
        "    system = platform.system().lower()\n"
        "    if system == \"windows\":\n"
        "        subprocess.Popen([\"cmd\", \"/c\", \"start\", \"cmd\", \"/k\"] + command)\n"
        "        return\n"
        "    if system == \"darwin\":\n"
        "        apple_script = (\n"
        "            \"tell application \\\"Terminal\\\" to do script \\\"{}\\\"\"\n"
        "        ).format(\" \".join(command))\n"
        "        subprocess.Popen([\"osascript\", \"-e\", apple_script])\n"
        "        return\n"
        "    terminal = os.environ.get(\"TERMINAL\")\n"
        "    if terminal:\n"
        "        subprocess.Popen([terminal, \"-e\"] + command)\n"
        "        return\n"
        "    for candidate in [\"x-terminal-emulator\", \"gnome-terminal\", \"konsole\", \"xfce4-terminal\"]:\n"
        "        if subprocess.call([\"which\", candidate], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0:\n"
        "            subprocess.Popen([candidate, \"-e\"] + command)\n"
        "            return\n"
        "    raise RuntimeError(\"No supported terminal emulator found.\")\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (simulated_dir / "simulator.py").write_text(
        "from __future__ import annotations\n\n"
        "import random\n\n"
        "\n"
        "def generate_sample(anomaly_rate: float = 0.2) -> dict:\n"
        "    \"\"\"Generate a simulated sensor reading with occasional anomalies.\"\"\"\n"
        "    is_anomaly = random.random() < anomaly_rate\n"
        "    range_min, range_max = (-1.0, 1.0) if not is_anomaly else (-4.0, 4.0)\n"
        "    return {\n"
        "        \"accel_x\": random.uniform(range_min, range_max),\n"
        "        \"accel_y\": random.uniform(range_min, range_max),\n"
        "        \"accel_z\": random.uniform(range_min, range_max),\n"
        "    }\n",
        encoding="utf-8",
    )

    (tests_dir / "run_simulation.py").write_text(
        "from __future__ import annotations\n\n"
        "from pipelines.inference import run_inference\n"
        "from sensors.simulated.simulator import generate_sample\n\n"
        "\n"
        "def main() -> None:\n"
        "    for _ in range(5):\n"
        "        sample = generate_sample()\n"
        "        features = [value for value in sample.values() if isinstance(value, (int, float))]\n"
        "        prediction = run_inference(features)\n"
        "        print(f\"sample={sample} prediction={prediction}\")\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (simulated_dir / "README.md").write_text(
        "# Simulated Sensors\n\n"
        "Use this folder to extend simulated sensor generation for testing.\n",
        encoding="utf-8",
    )

    for environment in config.environments:
        (env_dir / f"{environment}.md").write_text(
            f"# {environment.replace('_', ' ').title()} Setup\n\n"
            "Document environment-specific setup steps here.\n",
            encoding="utf-8",
        )

    return project_dir
