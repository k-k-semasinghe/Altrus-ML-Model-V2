from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path


@dataclass
class ProjectConfig:
    name: str
    sensors: list[str]
    anomalies: list[str]
    activities: list[str]
    environments: list[str]


def _yaml_lines(data: object, indent: int = 0) -> list[str]:
    prefix = "  " * indent
    if isinstance(data, dict):
        lines: list[str] = []
        for key, value in data.items():
            if isinstance(value, (dict, list)):
                lines.append(f"{prefix}{key}:")
                lines.extend(_yaml_lines(value, indent + 1))
            else:
                lines.append(f"{prefix}{key}: {value}")
        return lines
    if isinstance(data, list):
        lines = []
        for item in data:
            if isinstance(item, (dict, list)):
                lines.append(f"{prefix}-")
                lines.extend(_yaml_lines(item, indent + 1))
            else:
                lines.append(f"{prefix}- {item}")
        return lines
    return [f"{prefix}{data}"]


def _write_yaml(path: Path, data: dict[str, object]) -> None:
    lines = _yaml_lines(data)
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def create_project(config: ProjectConfig, output_dir: Path) -> Path:
    project_dir = output_dir / config.name
    project_dir.mkdir(parents=True, exist_ok=True)

    config_dir = project_dir / "config"
    sensors_dir = project_dir / "sensors"
    simulated_dir = sensors_dir / "simulated"
    models_dir = project_dir / "models"
    pipelines_dir = project_dir / "pipelines"
    scripts_dir = project_dir / "scripts"
    data_dir = project_dir / "data"
    env_dir = project_dir / "environments"
    tests_dir = project_dir / "tests"

    for directory in [
        config_dir,
        simulated_dir,
        models_dir,
        pipelines_dir,
        scripts_dir,
        data_dir,
        env_dir,
        tests_dir,
    ]:
        directory.mkdir(parents=True, exist_ok=True)

    _write_yaml(
        config_dir / "wristband_config.yaml",
        {
            "project": {
                "name": config.name,
                "created_at": datetime.utcnow().isoformat(timespec="seconds") + "Z",
            },
            "sensors": config.sensors,
            "anomalies": config.anomalies,
            "activities": config.activities,
            "environments": config.environments,
        },
    )

    (project_dir / "README.md").write_text(
        "# Wristband Sensor Fusion Project\n\n"
        "This project was generated by the Altrus CLI.\n"
        "Update `config/wristband_config.yaml` to adjust sensors, anomalies, activities, "
        "or environments.\n\n"
        "## Quick start\n\n"
        "Run the live scanner (listens for UDP sensor data):\n\n"
        "```bash\n"
        "altrus run\n"
        "```\n\n"
        "Run the live scanner with TCP instead:\n\n"
        "```bash\n"
        "altrus run --protocol tcp --port 5055\n"
        "```\n\n"
        "Run a short UDP simulation test:\n\n"
        "```bash\n"
        "python -m tests.run_simulation\n"
        "```\n",
        encoding="utf-8",
    )

    (models_dir / "user_model.py").write_text(
        "\"\"\"Replace this stub with your trained model.\"\"\"\n\n"
        "class UserModel:\n"
        "    \"\"\"Simple threshold-based model for simulated sensor data.\"\"\"\n\n"
        "    def __init__(self, threshold: float = 2.5) -> None:\n"
        "        self.threshold = threshold\n\n"
        "    def predict(self, features: list[float], activities: list[str]) -> dict:\n"
        "        \"\"\"Return a basic anomaly prediction and activity label.\"\"\"\n"
        "        if not features:\n"
        "            return {\"anomaly\": False, \"score\": 0.0, \"activity\": activities[0]}\n"
        "        max_abs = max(abs(value) for value in features)\n"
        "        score = min(max_abs / self.threshold, 1.0)\n"
        "        anomaly = max_abs >= self.threshold\n"
        "        activity = _classify_activity(max_abs, activities)\n"
        "        return {\"anomaly\": anomaly, \"score\": round(score, 3), \"activity\": activity}\n\n"
        "\n"
        "def _classify_activity(max_abs: float, activities: list[str]) -> str:\n"
        "    thresholds = [0.4, 1.2, 2.2]\n"
        "    if max_abs <= thresholds[0]:\n"
        "        return activities[0] if len(activities) > 0 else \"sleep\"\n"
        "    if max_abs <= thresholds[1]:\n"
        "        return activities[1] if len(activities) > 1 else \"rest\"\n"
        "    if max_abs <= thresholds[2]:\n"
        "        return activities[2] if len(activities) > 2 else \"walk\"\n"
        "    return activities[3] if len(activities) > 3 else \"run\"\n\n"
        "\n"
        "def load_model() -> UserModel:\n"
        "    return UserModel()\n",
        encoding="utf-8",
    )

    (pipelines_dir / "inference.py").write_text(
        "from __future__ import annotations\n\n"
        "from models.user_model import load_model\n\n"
        "\n"
        "def run_inference(features: list[float], activities: list[str]) -> dict:\n"
        "    model = load_model()\n"
        "    return model.predict(features, activities)\n",
        encoding="utf-8",
    )

    (scripts_dir / "run_inference.py").write_text(
        "from pipelines.inference import run_inference\n\n"
        "\n"
        "def main() -> None:\n"
        "    sample_features = [0.0, 0.0, 0.0]\n"
        "    activities = [\"sleep\", \"rest\", \"walk\", \"run\"]\n"
        "    result = run_inference(sample_features, activities)\n"
        "    print(f\"Inference result: {result}\")\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (scripts_dir / "run_live.py").write_text(
        "from __future__ import annotations\n\n"
        "import time\n\n"
        "from pipelines.inference import run_inference\n"
        "from sensors.simulated.simulator import generate_sample\n\n"
        "\n"
        "def _extract_features(sample: dict) -> list[float]:\n"
        "    return [value for value in sample.values() if isinstance(value, (int, float))]\n\n"
        "\n"
        "def main() -> None:\n"
        "    activities = [\"sleep\", \"rest\", \"walk\", \"run\"]\n"
        "    print(\"Running simulated live loop... (press Ctrl+C to stop)\")\n"
        "    while True:\n"
        "        sample = generate_sample()\n"
        "        features = _extract_features(sample)\n"
        "        prediction = run_inference(features, activities)\n"
        "        status = \"ANOMALY\" if prediction[\"anomaly\"] else \"normal\"\n"
        "        print(\n"
        "            f\"sample={sample} -> {status} \"\n"
        "            f\"activity={prediction['activity']} (score={prediction['score']})\"\n"
        "        )\n"
        "        time.sleep(1.0)\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (simulated_dir / "simulator.py").write_text(
        "from __future__ import annotations\n\n"
        "import random\n\n"
        "\n"
        "def generate_sample(anomaly_rate: float = 0.2) -> dict:\n"
        "    \"\"\"Generate a simulated sensor reading with occasional anomalies.\"\"\"\n"
        "    is_anomaly = random.random() < anomaly_rate\n"
        "    range_min, range_max = (-1.0, 1.0) if not is_anomaly else (-4.0, 4.0)\n"
        "    return {\n"
        "        \"accel_x\": random.uniform(range_min, range_max),\n"
        "        \"accel_y\": random.uniform(range_min, range_max),\n"
        "        \"accel_z\": random.uniform(range_min, range_max),\n"
        "    }\n",
        encoding="utf-8",
    )

    (tests_dir / "run_simulation.py").write_text(
        "from __future__ import annotations\n\n"
        "import json\n"
        "import socket\n"
        "import time\n\n"
        "from sensors.simulated.simulator import generate_sample\n\n"
        "\n"
        "def main() -> None:\n"
        "    host = \"127.0.0.1\"\n"
        "    port = 5055\n"
        "    print(f\"Sending UDP samples to {host}:{port}...\")\n"
        "    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n"
        "        for _ in range(5):\n"
        "            sample = generate_sample()\n"
        "            message = json.dumps(sample).encode(\"utf-8\")\n"
        "            sock.sendto(message, (host, port))\n"
        "            time.sleep(0.5)\n\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n",
        encoding="utf-8",
    )

    (simulated_dir / "README.md").write_text(
        "# Simulated Sensors\n\n"
        "Use this folder to extend simulated sensor generation for testing.\n",
        encoding="utf-8",
    )

    for environment in config.environments:
        (env_dir / f"{environment}.md").write_text(
            f"# {environment.replace('_', ' ').title()} Setup\n\n"
            "Document environment-specific setup steps here.\n",
            encoding="utf-8",
        )

    return project_dir
